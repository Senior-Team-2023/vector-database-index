import numpy as np
from worst_case_implementation import VecDBWorst

# from lsh_random_projection import VecDBLSH
# from buckets_hnsw import VecDB_buckets_HNSW
from ivf import VecDB
# from OldTrials.lsh import VecDB_lsh
# from one_level_lsh import VecDB_lsh_one_level

# from hnsw import VecDB_hnsw

# from OPQ32_IVF4096_HNSW_PQ32 import VecDB_OPQ32_IVF4096_HNSW_PQ32
# from IVF_HNSW import VecDB_ivf_hnsw
# from ivf_pq import VecDB_ivf_pq
import time
from dataclasses import dataclass
from typing import List

AVG_OVERX_ROWS = 10


@dataclass
class Result:
    run_time: float
    top_k: int
    db_ids: List[int]
    actual_ids: List[int]


def run_queries(db, np_rows, top_k, num_runs):
    results = []
    for _ in range(num_runs):
        # generate random query
        query = np.random.random((1, 70))

        tic = time.time()
        # retrive top_k records according to query
        db_ids = db.retrive(query, top_k)
        toc = time.time()
        run_time = toc - tic

        tic = time.time()
        # calculate the actual ids
        actual_ids = (
            np.argsort(
                np_rows.dot(query.T).T
                / (np.linalg.norm(np_rows, axis=1) * np.linalg.norm(query)),
                axis=1,
            )
            .squeeze()
            .tolist()[::-1]
        )
        toc = time.time()
        np_run_time = toc - tic

        results.append(Result(run_time, top_k, db_ids, actual_ids))
    return results


def eval(results: List[Result]):
    # scores are negative. So getting 0 is the best score.
    scores = []
    run_time = []
    for res in results:
        run_time.append(res.run_time)
        # case for retireving number not equal to top_k, socre will be the lowest
        if len(set(res.db_ids)) != res.top_k or len(res.db_ids) != res.top_k:
            print(
                "Wrong number of records retrieved, expected",
                res.top_k,
                "got",
                len(res.db_ids),
                "records",
            )
            scores.append(-1 * len(res.actual_ids) * res.top_k)
            continue
        score = 0
        for id in res.db_ids:
            try:
                ind = res.actual_ids.index(id)
                if ind > res.top_k * 3:
                    print(
                        "ID not in top_k,", "id", id, "index", ind, "top_k", res.top_k
                    )
                    score -= ind
            except:
                print("ID not in actual_ids", id)
                score -= len(res.actual_ids)
        scores.append(score)

    return sum(scores) / len(scores), sum(run_time) / len(run_time)


if __name__ == "__main__":
    # db = VecDBWorst()
    # db = VecDBLSH()
    # db = VecDB_buckets_HNSW()
    db = VecDB()
    # db = VecDB_lsh_one_level()
    # db = VecDB_hnsw()
    # db = VecDB_OPQ32_IVF4096_HNSW_PQ32()
    # db = VecDB_ivf_hnsw()
    # db = VecDB_ivf_pq()
    # generate random records
    np.random.seed(42)  # set seed value for random number generator
    records_np = np.random.random((10**6, 70))
    # convert random list to dict containing id and embed (random 70 dim vector)
    records_dict = [{"id": i, "embed": list(row)} for i, row in enumerate(records_np)]
    _len = len(records_np)
    # insert records into db
    db.insert_records(records_dict)

    # run queries
    # records_np: list of records generated by numpy, used to calculate the actual ids
    # 5: top_k
    # 10: number of runs (number of random queries to run)
    res = run_queries(db, records_np, 5, 1)
    print(eval(res))

    # records_np = np.concatenate([records_np, np.random.random((90000, 70))])
    # records_dict = [{"id": i + _len, "embed": list(row)} for i, row in enumerate(records_np[_len:])]
    # _len = len(records_np)
    # db.insert_records(records_dict)
    # res = run_queries(db, records_np, 5, 10)
    # print(eval(res))

    # records_np = np.concatenate([records_np, np.random.random((900000, 70))])
    # records_dict = [{"id": i + _len, "embed": list(row)} for i, row in enumerate(records_np[_len:])]
    # _len = len(records_np)
    # db.insert_records(records_dict)
    # res = run_queries(db, records_np, 5, 10)
    # eval(res)

    # records_np = np.concatenate([records_np, np.random.random((4000000, 70))])
    # records_dict = [{"id": i + _len, "embed": list(row)} for i, row in enumerate(records_np[_len:])]
    # _len = len(records_np)
    # db.insert_records(records_dict)
    # res = run_queries(db, records_np, 5, 10)
    # eval(res)

    # records_np = np.concatenate([records_np, np.random.random((5000000, 70))])
    # records_dict = [{"id": i + _len, "embed": list(row)} for i, row in enumerate(records_np[_len:])]
    # _len = len(records_np)
    # db.insert_records(records_dict)
    # res = run_queries(db, records_np, 5, 10)
    # eval(res)

    # records_np = np.concatenate([records_np, np.random.random((5000000, 70))])
    # records_dict = [{"id": i +  _len, "embed": list(row)} for i, row in enumerate(records_np[_len:])]
    # _len = len(records_np)
    # db.insert_records(records_dict)
    # res = run_queries(db, records_np, 5, 10)
    # eval(res)
